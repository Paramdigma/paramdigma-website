{% assign title = "" %}
{% assign id = "" %}
{% if include.title %}
    {% assign title = include.title %}
    {% assign id = {{include.title | downcase | | replace: ' ', '-'}} %}  
{% else %}
     {% assign title = include.model %} 
     {% assign id = {{include.model | downcase | | replace: '/', '-'}} %}  
{% endif %}

<div id="{{id}}" class="container threejs-box" title="{{title}}">
</div>

<script src="{{site.url}}/assets/js/threejs/three.js"></script>
<script src="{{site.url}}/assets/js/threejs/OrbitControls.js"></script>
<script src="{{site.url}}/assets/js/threejs/OBJLoader.js"></script>
<script>
            var parent = document.getElementById("{{id}}");
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, 600/350, 1, 1000 );
            var renderer = new THREE.WebGLRenderer({alpha:true});

            var controls = new THREE.OrbitControls( camera, renderer.domElement );

            const fitCameraToObject = function ( camera, object, offset, controls ) {

                offset = offset || 1.25;

                const boundingBox = new THREE.Box3();

                // get bounding box of object - this will be used to setup controls and camera
                boundingBox.setFromObject( object );

                const center = boundingBox.getCenter();

                const size = boundingBox.getSize();

                // get the max side of the bounding box (fits to width OR height as needed )
                const maxDim = Math.max( size.x, size.y, size.z );
                const fov = camera.fov * ( Math.PI / 180 );
                let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) );

                cameraZ *= offset; // zoom out a little so that objects don't fill the screen

                camera.position.z = cameraZ;
                const minZ = boundingBox.min.z;
                const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ;

                camera.far = cameraToFarEdge * 3;
                camera.updateProjectionMatrix();

                if ( controls ) {

                // set camera to rotate around center of loaded object
                controls.target = center;

                console.log(center);
                console.log(camera.position);
                // prevent camera from zooming out far enough to create far plane cutoff
                controls.maxDistance = cameraToFarEdge * 2;

                controls.saveState();

                } else {
                    camera.lookAt( center )
                }
            }
            
            //controls.autoRotate = true;


            renderer.setSize( 600, 350 );
            renderer.domElement.className += ' threejs-canvas';
            parent.appendChild(renderer.domElement);
            
            window.addEventListener( 'resize', onWindowResize, false );

            var ammountX = 100;
            var ammountY = 100;
            var separation = 100;
            var numParticles = ammountX * ammountY;
            var positions = new Float32Array(numParticles * 3);
            var scales = new Float32Array(numParticles);

            
            var geometry = new THREE.Geometry();
            var t = 0;
            var h = 200;
            var a = 1000;
            var timeStep = 0.07;

            var i = 0, j=0;
            for (let x = 0; x < ammountX; x++) {
                for (let y = 0; y < ammountY; y++) {
                    let rX = x * 100;
                    let rY = y * 100;
                    geometry.vertices.push(new THREE.Vector3(rX,rY,0));

                    positions[i] = x * separation - ((ammountX * separation)/2);
                    positions[i+1] = 0;
                    positions[i+2] = y * separation - ((ammountY*separation)/2);

                    scales[j] = 1;

                    i+=3;
                    j++;
                }
            }
            var bufferGeom = new THREE.BufferGeometry();
            bufferGeom.addAttribute('position',new THREE.BufferAttribute(positions,3));
            bufferGeom.addAttribute('scale', new THREE.BufferAttribute(scales,1));

            var ptCldMaterial = new THREE.PointsMaterial({
            color: 0x000000
            });
            var pointCloud = new THREE.Points(geometry, ptCldMaterial);
            scene.add(pointCloud);
            fitCameraToObject(camera,pointCloud,5,controls);
            
            camera.position.x = 5000;
            camera.position.y = 0;
            camera.target = new THREE.Vector3(5000,5000,0);
            camera.position.z = 50;

            function onWindowResize() {
                console.log("Testing width: " + parent.clientWidth);
                camera.aspect = parent.clientWidth / parent.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( parent.clientWidth, parent.clientHeight );
            }

			var animate = function () {
                requestAnimationFrame( animate );
                
                geometry.vertices.forEach(particle => {
                    let dist = Math.sqrt(particle.x*particle.x + particle.y*particle.y);
                    particle.z = h*Math.sin(dist/a + t);
                });

                geometry.verticesNeedUpdate = true;

                controls.update();
                renderer.render( scene, camera );
                t += timeStep;
            };
            
            animate();  
</script>